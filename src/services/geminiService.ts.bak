// Gemini API service for Glyssa
// This service handles communication with Google's Gemini API

// Import the error handler
import { handleGeminiApiError } from './geminiErrorHandler';

// Configuration
// Using the latest v1 API instead of v1beta
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent';
const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY || '';

// Use API key as URL parameter as an alternative method
const getApiUrl = () => `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`;

// Log key prefix to help with debugging (never log the full key)
console.log('Gemini API Key prefix:', GEMINI_API_KEY ? GEMINI_API_KEY.substring(0, 4) + '...' : 'not set');
console.log('Gemini API Key length:', GEMINI_API_KEY ? GEMINI_API_KEY.length : 0);
console.log('Environment variable exists:', process.env.NEXT_PUBLIC_GEMINI_API_KEY ? 'yes' : 'no');

// API retry configuration
const MAX_RETRIES = 2;          // Maximum number of retries before falling back
const RETRY_DELAY_MS = 1000;    // Delay between retries in milliseconds

export interface GeminiResponse {
  text: string;
  annotations?: {
    startLine: number;
    endLine: number;
    explanation: string;
  }[];
}

interface CodeExplanationRequest {
  code: string;
  language?: string;
  request?: string;
}

/**
 * Makes a Gemini API call with retry mechanism for handling overloaded models
 * @param requestBody The request body to send to the Gemini API
 * @param retryCount Current retry attempt (internal use)
 * @returns The API response
 */
async function callGeminiWithRetry(requestBody: any, retryCount: number = 0): Promise<Response> {
  try {
    console.log('Making API call to Gemini...');
    
    // Use the API key in the URL instead of as a header
    const apiUrl = getApiUrl();
    console.log('Calling Gemini API with URL:', apiUrl.replace(GEMINI_API_KEY, '[REDACTED]'));
    console.log('API key available for request:', GEMINI_API_KEY ? 'yes' : 'no');
    console.log('API key length:', GEMINI_API_KEY.length);
    
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });
    
    console.log('Gemini API response status:', response.status);
    
    // If we get a 503 error and haven't exceeded max retries, try again
    if (!response.ok && response.status === 503 && retryCount < MAX_RETRIES) {
      console.log(`Gemini API returned 503, retrying (attempt ${retryCount + 1}/${MAX_RETRIES})...`);
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * (retryCount + 1)));
      
      // Retry the API call
      return callGeminiWithRetry(requestBody, retryCount + 1);
    }
    
    return response;
  } catch (error) {
    console.error('Error making Gemini API call:', error);
    
    // If we haven't exceeded max retries, try again
    if (retryCount < MAX_RETRIES) {
      console.log(`Network error with Gemini API, retrying (attempt ${retryCount + 1}/${MAX_RETRIES})...`);
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * (retryCount + 1)));
      
      // Retry the API call
      return callGeminiWithRetry(requestBody, retryCount + 1);
    }
    
    // Create a mock response to indicate the API call failed
    const mockResponse = new Response(
      JSON.stringify({ error: { message: 'API call failed after retries' } }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
    
    return mockResponse;
  }
}

/**
 * Parse Gemini API response
 */
function parseResponse(data: any): GeminiResponse {
  try {
    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts) {
      return { text: "Invalid response from AI service." };
    }
    
    const candidate = data.candidates[0];
    const part = candidate.content.parts[0];
    
    return {
      text: part.text,
      annotations: extractAnnotations(part.text)
    };
  } catch (error) {
    console.error('Error parsing Gemini response:', error);
    return { text: "Error processing AI response." };
  }
}

/**
 * Extract line annotations from response text
 */
function extractAnnotations(text: string) {
  const annotations = [];
  
  // Match [Line X] or [Lines X-Y] patterns
  const lineRegex = /\[Line(?:s)?\s+(\d+)(?:-(\d+))?\]/g;
  let match;
  
  while ((match = lineRegex.exec(text)) !== null) {
    const startLine = parseInt(match[1], 10);
    
    // Get the end line if it exists, otherwise use start line
    const endLine = match[2] ? parseInt(match[2], 10) : startLine;
    
    // Get the text after the line annotation until the next line annotation or end of text
    const nextMatch = lineRegex.exec(text);
    const endIndex = nextMatch ? nextMatch.index : text.length;
    lineRegex.lastIndex = match.index + match[0].length; // Reset regex to continue from end of current match
    
    // Extract the explanation
    const explanationStart = match.index + match[0].length;
    const explanation = text.substring(explanationStart, endIndex).trim();
    
    if (startLine && endLine) {
      annotations.push({
        startLine,
        endLine,
        explanation
      });
    }
  }
  
  return annotations.length > 0 ? annotations : undefined;
}

/**
 * Generate a fallback explanation when the Gemini API is unavailable
 */
function generateFallbackExplanation(code: string, language?: string): string {
  // Perform code analysis
  const analysis = analyzeCode(code);
  
  // Build a more detailed explanation
  let explanation = `Sorry, the AI service is currently experiencing high demand. Here's an automated explanation instead:\n\n`;
  
  // Use provided language if available, otherwise use the detected one
  const codeLanguage = language || analysis.language;
  explanation += `This is a ${codeLanguage} snippet with ${analysis.lineCount} lines.\n\n`;
  
  // Add function information if available
  if (analysis.functions.length > 0) {
    explanation += `Functions identified: ${analysis.functions.join(', ')}\n\n`;
  }
  
  // Add class information if available
  if (analysis.classes.length > 0) {
    explanation += `Classes identified: ${analysis.classes.join(', ')}\n\n`;
  }
  
  // Add import information if available
  if (analysis.imports.length > 0) {
    explanation += `Dependencies: ${analysis.imports.join(', ')}\n\n`;
  }
  
  // Add key features if identified
  if (analysis.keyFeatures.length > 0) {
    explanation += `Key features: ${analysis.keyFeatures.join(', ')}\n\n`;
  }
  
  // Analyze specific code context based on the current code snippet
  if (code.includes('console.error') && code.includes('Gemini API error')) {
    explanation += `This code appears to be handling an error from the Gemini API. It logs the error details to the console and returns an error message to the user.\n\n`;
  }
  
  if (code.includes('response.status === 503')) {
    explanation += `The code includes specific handling for HTTP 503 errors (Service Unavailable), which typically occur when a service is temporarily overloaded or undergoing maintenance.\n\n`;
  }
  
  explanation += `This is an automated explanation generated when the AI service is unavailable.`;
  
  return explanation;
}

/**
 * Generate a fallback explanation with line markers for highlighting when Gemini API is unavailable
 * This version is specifically designed to work with the TTS line highlighting feature
 */

/**
 * Generate a simple, reliable fallback explanation when Gemini API is unavailable
 */
function generateFallbackExplanationWithLineMarkers(code: string, language?: string): string {
  // Split the code into lines for analysis
  const lines = code.split('\n');
  const lineCount = lines.length;
  
  // Create a simple but effective fallback with proper line markers
  let explanation = "";
  
  // Add introduction
  explanation += "[Line 1] I'll explain this code step by step.

";
  
  // Add basic code overview
  if (language) {
    explanation += "[Line 2] This is " + language + " code with " + lineCount + " lines.

";
  } else {
    explanation += "[Line 2] This code has " + lineCount + " lines.

";
  }
  
  // Identify and explain key structures
  let currentLine = 3;
  
  // Look for imports/requires
  const importLines = lines.findIndex(line => 
    line.includes('import ') || line.includes('require('));
  if (importLines !== -1) {
    explanation += "[Line " + (importLines + 1) + "] Here we're importing dependencies needed for the code.

";
    currentLine++;
  }
  
  // Look for functions
  const functionLines = lines.findIndex(line => 
    line.includes('function ') || line.match(/\w+\s*\([^)]*\)\s*{/));
  if (functionLines !== -1) {
    explanation += "[Line " + (functionLines + 1) + "] This line defines a function.

";
    currentLine++;
  }
  
  // Look for API calls or key operations
  const apiCallLines = lines.findIndex(line => 
    line.includes('fetch(') || line.includes('axios.') || line.includes('await '));
  if (apiCallLines !== -1) {
    explanation += "[Line " + (apiCallLines + 1) + "] This line makes an API call or performs an asynchronous operation.

";
    currentLine++;
  }
  
  // Look for error handling
  const errorHandlingLines = lines.findIndex(line => 
    line.includes('try ') || line.includes('catch '));
  if (errorHandlingLines !== -1) {
    explanation += "[Line " + (errorHandlingLines + 1) + "] This is part of error handling to manage exceptions.

";
    currentLine++;
  }
  
  // Add summary
  explanation += "[Line " + lineCount + "] This completes the code.

";
  explanation += "Note: This is a basic automated explanation while the AI service is unavailable.";
  
  return explanation;
}
    
    if (analysis.keyFeatures.length > 0) {
      explanation += `It features ${analysis.keyFeatures.join(', ')}. `;
    }
  }
  explanation += '\n\n';
  
  // Explain imports if found
  if (importLines.length > 0) {
    importLines.slice(0, 3).forEach(lineIndex => {
      explanation += `[Line${lineIndex + 1}] This line imports necessary dependencies. `;
      if (lines[lineIndex].includes('from ')) {
        const match = lines[lineIndex].match(/from\s+['"]([^'"]+)['"]/); 
        if (match) {
          explanation += `It's importing from the '${match[1]}' package. `;
        }
      }
      explanation += '\n\n';
    });
  }
  
  // Explain functions if found
  if (functionLines.length > 0) {
    functionLines.slice(0, 3).forEach(lineIndex => {
      explanation += `[Line${lineIndex + 1}] This line defines a function. `;
      const functionMatch = lines[lineIndex].match(/function\s+(\w+)|const\s+(\w+)\s*=\s*\(|async\s+function\s+(\w+)/);
      if (functionMatch) {
        const name = functionMatch[1] || functionMatch[2] || functionMatch[3];
        explanation += `The function named '${name}' is declared here. `;
      }
      explanation += '\n\n';
    });
  }
  
  // Explain classes if found
  if (classLines.length > 0) {
    classLines.slice(0, 2).forEach(lineIndex => {
      explanation += `[Line${lineIndex + 1}] This line defines a class. `;
      const classMatch = lines[lineIndex].match(/class\s+(\w+)/);
      if (classMatch) {
        explanation += `The class '${classMatch[1]}' is being defined here. `;
      }
      explanation += '\n\n';
    });
  }
  
  // Explain control flow if found
  if (controlFlowLines.length > 0) {
    controlFlowLines.slice(0, 3).forEach(lineIndex => {
      if (lines[lineIndex].includes('if ')) {
        explanation += `[Line${lineIndex + 1}] This is a conditional statement checking if certain conditions are met. `;
      } else if (lines[lineIndex].includes('for ')) {
        explanation += `[Line${lineIndex + 1}] This is a loop that iterates through a collection or for a certain number of times. `;
      } else if (lines[lineIndex].includes('while ')) {
        explanation += `[Line${lineIndex + 1}] This is a while loop that continues as long as the specified condition is true. `;
      }
      explanation += '\n\n';
    });
  }
  
  // Explain return statements if found
  if (returnLines.length > 0) {
    returnLines.slice(0, 2).forEach(lineIndex => {
      explanation += `[Line${lineIndex + 1}] This line returns a value from the function. `;
      explanation += '\n\n';
    });
  }
  
  // Add a note about error handling if present
  if (lines.some(line => line.includes('try') || line.includes('catch'))) {
    const tryLineIndex = lines.findIndex(line => line.includes('try'));
    if (tryLineIndex !== -1) {
      explanation += `[Line${tryLineIndex + 1}] This begins a try-catch block for error handling. If an error occurs in the try block, it will be caught and handled in the catch block.\n\n`;
    }
  }
  
  // Add final summary with line markers
  const lastLineIndex = analysis.lineCount - 1;
  explanation += `[Line${lastLineIndex + 1}] This is the final line of the code snippet. `; 
  
  if (analysis.keyFeatures.length > 0) {
    explanation += `Overall, this code demonstrates ${analysis.keyFeatures.join(', ')}.\n\n`;
  }
  
  explanation += `This automated explanation with line references was generated to maintain highlighting functionality.`;
  
  return explanation;
}

/**
 * Analyze code to identify key elements for the fallback explanation
 */
function analyzeCode(code: string): {
  language: string;
  lineCount: number;
  functions: string[];
  classes: string[];
  imports: string[];
  keyFeatures: string[];
} {
  const lines = code.split('\n');
  const lineCount = lines.length;
  const functions: string[] = [];
  const classes: string[] = [];
  const imports: string[] = [];
  const keyFeatures: string[] = [];
  
  // Language detection
  let language = 'code';
  if (code.includes('function') || code.includes('const') || code.includes('let') || code.includes('var')) {
    language = 'JavaScript';
  } else if (code.includes('def ') || code.includes('import ') && !code.includes('{')) {
    language = 'Python';
  } else if (code.includes('public static void main')) {
    language = 'Java';
  } else if (code.includes('#include')) {
    language = 'C/C++';
  }
  
  // Extract function declarations
  const functionRegex = /(?:function\s+([\w$]+)|(?:const|let|var)\s+([\w$]+)\s*=\s*(?:function|\([^)]*\)\s*=>)|(\\w+)\s*:\s*function|(?:async\s+)?([\w$]+)\s*\([^)]*\)\s*{)/g;
  let match;
  while ((match = functionRegex.exec(code)) !== null) {
    const functionName = match[1] || match[2] || match[3] || match[4];
    if (functionName && !functions.includes(functionName)) {
      functions.push(functionName);
    }
  }
  
  // Extract class declarations
  const classRegex = /class\s+([\w$]+)(?:\s+extends\s+([\w$]+))?/g;
  while ((match = classRegex.exec(code)) !== null) {
    classes.push(match[1] + (match[2] ? ` (extends ${match[2]})` : ''));
  }
  
  // Extract imports
  const importRegex = /import\s+(?:{[^}]*}|[\w$*]+)\s+from\s+['"']([^'"']+)['"']|require\s*\(['"']([^'"']+)['"']\)/g;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1] || match[2]);
  }
  
  // Look for key features
  if (code.includes('useEffect')) keyFeatures.push('React hooks');
  if (code.includes('useState')) keyFeatures.push('state management');
  if (code.includes('fetch(') || code.includes('axios')) keyFeatures.push('API calls');
  if (code.includes('async') && code.includes('await')) keyFeatures.push('asynchronous operations');
  if (code.includes('try') && code.includes('catch')) keyFeatures.push('error handling');
  if (code.includes('map(') || code.includes('filter(') || code.includes('reduce(')) keyFeatures.push('array operations');
  if (code.includes('console.error') || code.includes('console.log')) keyFeatures.push('console logging');
  if (code.includes('export')) keyFeatures.push('module exports');
  
  return {
    language,
    lineCount,
    functions,
    classes,
    imports,
    keyFeatures
  };
}

/**
 * Explains code using Gemini API
 */
export const explainCode = async (
  request: CodeExplanationRequest
): Promise<GeminiResponse> => {
  try {
    const { code, language = 'javascript', request: userRequest = 'Explain this code' } = request;
    
    console.log('Explaining code with content:', { codeLength: code?.length, language });
    
    const prompt = `
You are an AI code tutor. Explain the EXACT code below in detail. DO NOT explain a generic example - only explain THIS specific code:

\`\`\`${language}
${code}
\`\`\`

RESTRICTIONS:
1. DO NOT MAKE UP CODE - only explain the exact code provided above
2. DO NOT provide a generic explanation - analyze this specific implementation
3. Reference specific line numbers when explaining the code
4. Provide a detailed breakdown of what each important part of the code does

Your analysis should include:
1. What the code does overall
2. Key functions and their purpose
3. Any important patterns or techniques used

FOLLOW THESE INSTRUCTIONS PRECISELY. The user depends on accurate explanation of their actual code.
`;

    // Construct the request body for the Gemini API
    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: prompt
            }
          ]
        }
      ]
    };
    
    // Use the retry mechanism for API calls
    const response = await callGeminiWithRetry(requestBody);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error:', errorText);
      
      // If the model is overloaded (503 error) or API key is invalid (400 error), provide a fallback explanation with line markers for TTS
      if (response.status === 503 || response.status === 400) {
        console.log(`Gemini API ${response.status === 503 ? "overloaded (503)" : "authentication error (400)"}, using enhanced fallback with line markers for TTS highlighting`);
        return { 
          text: generateFallbackExplanationWithLineMarkers(code, language)
        };
      }
      
      return { text: `AI service unavailable (${response.status}). Please try again later.` };
    }

    const data = await response.json();
    return parseResponse(data);
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    return { text: "Error connecting to the AI service." };
  }
};

/**
 * Reads code aloud using Gemini API
 * This generates a narrative explanation suitable for text-to-speech
 */
export const readCodeAloud = async (
  request: CodeExplanationRequest
): Promise<GeminiResponse> => {
  try {
    const { code, language = 'javascript' } = request;
    console.log('Reading code aloud with content:', { codeLength: code?.length, language });
    
    const prompt = `
You are an AI code tutor. Generate a narrative explanation of the EXACT code below. DO NOT explain a generic example - only explain THIS specific code:

\`\`\`${language}
${code}
\`\`\`

RESTRICTIONS:
1. DO NOT MAKE UP CODE - only explain the exact code provided above
2. DO NOT provide a generic explanation - analyze this specific implementation
3. For each section you explain, first say "[Line X]" where X is the line number you're referring to
4. Use natural, conversational language as if you're tutoring someone verbally
5. Pause between explanations of different sections with "..." to create natural breaks
6. Use a friendly, engaging tone suitable for a tutor
7. Break complex explanations into shorter, clearer segments
8. Your explanation will be read aloud, so structure it to be easy to follow when spoken

FORMAT YOUR EXPLANATION LIKE THIS:
"Let me walk you through this code...

[Line 1] This line does X... It's important because...

[Line 3] Next, we see Y... This connects to the previous part by..."

FOLLOW THESE INSTRUCTIONS PRECISELY. The user depends on accurate explanation of their actual code that is properly highlighted as you speak.
`;

    // Construct the request body for the Gemini API
    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: prompt
            }
          ]
        }
      ]
    };
    
    // Use the retry mechanism for API calls
    const response = await callGeminiWithRetry(requestBody);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error:', errorText);
      
      // If the model is overloaded (503 error) or API key is invalid (400 error), provide a fallback explanation with line markers for TTS
      if (response.status === 503 || response.status === 400) {
        console.log(`Gemini API ${response.status === 503 ? "overloaded (503)" : "authentication error (400)"}, using enhanced fallback with line markers for TTS highlighting`);
        return { 
          text: generateFallbackExplanationWithLineMarkers(code, language)
        };
      }
      
      return { text: `AI service unavailable (${response.status}). Please try again later.` };
    }

    const data = await response.json();
    return parseResponse(data);
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    return { text: "Error connecting to the AI service." };
  }
};

/**
 * Answers a question about specific code
 */
export const answerCodeQuestion = async (
  code: string,
  question: string,
  language: string = 'javascript',
  highlightedCode?: string
): Promise<GeminiResponse> => {
  try {
    console.log('Answering question about code:', { codeLength: code?.length, language, question });
    
    let prompt = `
I have a question about this code:

\`\`\`${language}
${code}
\`\`\`

My question is: ${question}
`;

    if (highlightedCode) {
      prompt += `\nSpecifically, I'm asking about this part:\n\`\`\`${language}\n${highlightedCode}\n\`\`\``;
    }
    
    prompt += `\n\nPlease answer my specific question in detail, referring to line numbers where appropriate. If you need to explain a concept, include short examples.`;

    // Construct the request body for the Gemini API
    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: prompt
            }
          ]
        }
      ]
    };
    
    // Use the retry mechanism for API calls
    const response = await callGeminiWithRetry(requestBody);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error:', errorText);
      
      // If the model is overloaded (503 error) or API key is invalid (400 error), provide a fallback explanation with line markers for TTS
      if (response.status === 503 || response.status === 400) {
        console.log(`Gemini API ${response.status === 503 ? "overloaded (503)" : "authentication error (400)"}, using enhanced fallback with line markers for TTS highlighting`);
        return { 
          text: generateFallbackExplanationWithLineMarkers(code, language)
        };
      }
      
      return { text: `AI service unavailable (${response.status}). Please try again later.` };
    }

    const data = await response.json();
    return parseResponse(data);
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    return { text: "Error connecting to the AI service." };
  }
};
